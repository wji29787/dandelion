define(["./when-b43ff45e","./Check-d404a0fe","./Math-336da716","./Cartesian3-2b5b9afe","./Cartesian2-577f67dc","./Transforms-18f02e2b","./RuntimeError-bf10f3d5","./WebGLConstants-56de22c0","./ComponentDatatype-8956ad9a","./GeometryAttribute-5eb995bc","./JulianDate-53cdb307","./RequestType-beb1291d","./GeometryAttributes-fbf888b4","./IndexDatatype-c5295474","./IntersectionTests-8ff35218","./Plane-5b30f0ff","./GeometryOffsetAttribute-9f7392ac","./VertexFormat-89c0971b","./arrayRemoveDuplicates-a7dee4b8","./EllipsoidTangentPlane-51ba1d6b","./EllipsoidRhumbLine-b4761ded","./PolygonPipeline-6cd12a44","./PolylineVolumeGeometryLibrary-8765c50e","./EllipsoidGeodesic-47c65dee","./PolylinePipeline-76ef9442","./CorridorGeometryLibrary-63ed7059"],function(pt,t,ft,ct,c,h,e,r,ht,gt,a,i,Ct,bt,n,o,P,x,g,s,l,N,C,d,u,At){"use strict";var vt=new ct.Cartesian3,wt=new ct.Cartesian3,_t=new ct.Cartesian3,Gt=new ct.Cartesian3,O=new ct.Cartesian3,Tt=new ct.Cartesian3,Et=new ct.Cartesian3,Ft=new ct.Cartesian3;function b(t,e){for(var r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function Lt(t,e,r,a,i,n){var o=t.normals,s=t.tangents,l=t.bitangents,d=ct.Cartesian3.normalize(ct.Cartesian3.cross(r,e,Et),Et);n.normal&&At.CorridorGeometryLibrary.addAttribute(o,e,a,i),n.tangent&&At.CorridorGeometryLibrary.addAttribute(s,d,a,i),n.bitangent&&At.CorridorGeometryLibrary.addAttribute(l,r,a,i)}function I(t,e,r){var a,i=t.positions,n=t.corners,o=t.endPositions,s=t.lefts,l=t.normals,d=new Ct.GeometryAttributes,u=0,m=0,y=0;if(0===n.length){for(mt=0;mt<i.length;mt+=2)m+=i[mt].length,u+=i[mt+1].length;var y=(O=u+m)-6,p=bt.IndexDatatype.createTypedArray(O/3,y),f=new Float64Array(O),c={normals:F=e.normal?new Float32Array(O):void 0,tangents:e.tangent?new Float32Array(O):void 0,bitangents:e.bitangent?new Float32Array(O):void 0},h=0,g=O-1,C=0,b=i.length;for(mt=0;mt<b;mt+=2){var A=i[mt],v=i[mt+1];f.set(A,h),f.set(v,g-v.length+1);for(var w=0,_=A.length;w<_;w+=3)R=r.geodeticSurfaceNormal(ct.Cartesian3.fromArray(A,w,Et),Et),B=r.geodeticSurfaceNormal(ct.Cartesian3.fromArray(v,_-3-w,Ft),Ft),I=ct.Cartesian3.normalize(ct.Cartesian3.add(R,B,I),I),At.CorridorGeometryLibrary.addAttribute(F,I,h,g),mt===b-2&&w===_-3||(V=(P=h/3)+1,L=(D=(g-2)/3)-1,p[C++]=L,p[C++]=D,p[C++]=V,p[C++]=V,p[C++]=D,p[C++]=P,h+=3,g-=3)}}else{for(mt=0;mt<i.length;mt+=2)u+=a=i[mt].length-3,y+=2*a,m+=i[mt+1].length-3;for(u+=3,m+=3,mt=0;mt<n.length;mt++){U=n[mt];var G=n[mt].leftPositions;pt.defined(G)?u+=a=G.length:m+=a=n[mt].rightPositions.length,y+=a}var T,E=pt.defined(o);E&&(u+=T=o[0].length-3,m+=T,y+=6*(T/=3));var F,L,D,V,P,x,N,O=u+m,f=new Float64Array(O),c={normals:F=e.normal?new Float32Array(O):void 0,tangents:e.tangent?new Float32Array(O):void 0,bitangents:e.bitangent?new Float32Array(O):void 0},h=0,g=O-1,I=vt,M=wt,S=T/2,p=bt.IndexDatatype.createTypedArray(O/3,y),C=0;if(E){N=_t,x=Gt;var k=o[0],I=ct.Cartesian3.fromArray(l,0,I),M=ct.Cartesian3.fromArray(s,0,M);for(mt=0;mt<S;mt++)N=ct.Cartesian3.fromArray(k,3*(S-1-mt),N),x=ct.Cartesian3.fromArray(k,3*(S+mt),x),At.CorridorGeometryLibrary.addAttribute(f,x,h),At.CorridorGeometryLibrary.addAttribute(f,N,void 0,g),Lt(c,I,M,h,g,e),P=(D=h/3)+1,V=(L=(g-2)/3)-1,p[C++]=L,p[C++]=D,p[C++]=V,p[C++]=V,p[C++]=D,p[C++]=P,h+=3,g-=3}var R,B,z=0,H=0,A=i[z++],v=i[z++];for(f.set(A,h),f.set(v,g-v.length+1),M=ct.Cartesian3.fromArray(s,H,M),a=v.length-3,mt=0;mt<a;mt+=3)R=r.geodeticSurfaceNormal(ct.Cartesian3.fromArray(A,mt,Et),Et),B=r.geodeticSurfaceNormal(ct.Cartesian3.fromArray(v,a-mt,Ft),Ft),Lt(c,I=ct.Cartesian3.normalize(ct.Cartesian3.add(R,B,I),I),M,h,g,e),P=(D=h/3)+1,V=(L=(g-2)/3)-1,p[C++]=L,p[C++]=D,p[C++]=V,p[C++]=V,p[C++]=D,p[C++]=P,h+=3,g-=3;for(R=r.geodeticSurfaceNormal(ct.Cartesian3.fromArray(A,a,Et),Et),B=r.geodeticSurfaceNormal(ct.Cartesian3.fromArray(v,a,Ft),Ft),I=ct.Cartesian3.normalize(ct.Cartesian3.add(R,B,I),I),H+=3,mt=0;mt<n.length;mt++){var U,Y,W,q=(U=n[mt]).leftPositions,J=U.rightPositions,j=Tt,K=_t,Q=Gt;if(I=ct.Cartesian3.fromArray(l,H,I),pt.defined(q)){for(Lt(c,I,M,void 0,g,e),g-=3,Y=P,W=V,w=0;w<q.length/3;w++)j=ct.Cartesian3.fromArray(q,3*w,j),p[C++]=Y,p[C++]=W-w-1,p[C++]=W-w,At.CorridorGeometryLibrary.addAttribute(f,j,void 0,g),K=ct.Cartesian3.fromArray(f,3*(W-w-1),K),Q=ct.Cartesian3.fromArray(f,3*Y,Q),Lt(c,I,M=ct.Cartesian3.normalize(ct.Cartesian3.subtract(K,Q,M),M),void 0,g,e),g-=3;j=ct.Cartesian3.fromArray(f,3*Y,j),K=ct.Cartesian3.subtract(ct.Cartesian3.fromArray(f,3*W,K),j,K),Q=ct.Cartesian3.subtract(ct.Cartesian3.fromArray(f,3*(W-w),Q),j,Q),Lt(c,I,M=ct.Cartesian3.normalize(ct.Cartesian3.add(K,Q,M),M),h,void 0,e),h+=3}else{for(Lt(c,I,M,h,void 0,e),h+=3,Y=V,W=P,w=0;w<J.length/3;w++)j=ct.Cartesian3.fromArray(J,3*w,j),At.CorridorGeometryLibrary.addAttribute(f,j,h),p[C++]=Y,p[C++]=W+w,p[C++]=W+w+1,K=ct.Cartesian3.fromArray(f,3*Y,K),Q=ct.Cartesian3.fromArray(f,3*(W+w),Q),Lt(c,I,M=ct.Cartesian3.normalize(ct.Cartesian3.subtract(K,Q,M),M),h,void 0,e),h+=3;j=ct.Cartesian3.fromArray(f,3*Y,j),K=ct.Cartesian3.subtract(ct.Cartesian3.fromArray(f,3*(W+w),K),j,K),Q=ct.Cartesian3.subtract(ct.Cartesian3.fromArray(f,3*W,Q),j,Q),Lt(c,I,M=ct.Cartesian3.normalize(ct.Cartesian3.negate(ct.Cartesian3.add(Q,K,M),M),M),void 0,g,e),g-=3}for(A=i[z++],v=i[z++],A.splice(0,3),v.splice(v.length-3,3),f.set(A,h),f.set(v,g-v.length+1),a=v.length-3,H+=3,M=ct.Cartesian3.fromArray(s,H,M),w=0;w<v.length;w+=3)R=r.geodeticSurfaceNormal(ct.Cartesian3.fromArray(A,w,Et),Et),B=r.geodeticSurfaceNormal(ct.Cartesian3.fromArray(v,a-w,Ft),Ft),Lt(c,I=ct.Cartesian3.normalize(ct.Cartesian3.add(R,B,I),I),M,h,g,e),D=(P=h/3)-1,L=(V=(g-2)/3)+1,p[C++]=L,p[C++]=D,p[C++]=V,p[C++]=V,p[C++]=D,p[C++]=P,h+=3,g-=3;h-=3,g+=3}if(Lt(c,I=ct.Cartesian3.fromArray(l,l.length-3,I),M,h,g,e),E){h+=3,g-=3,N=_t,x=Gt;var X=o[1];for(mt=0;mt<S;mt++)N=ct.Cartesian3.fromArray(X,3*(T-mt-1),N),x=ct.Cartesian3.fromArray(X,3*mt,x),At.CorridorGeometryLibrary.addAttribute(f,N,void 0,g),At.CorridorGeometryLibrary.addAttribute(f,x,h),Lt(c,I,M,h,g,e),D=(P=h/3)-1,L=(V=(g-2)/3)+1,p[C++]=L,p[C++]=D,p[C++]=V,p[C++]=V,p[C++]=D,p[C++]=P,h+=3,g-=3}}if(d.position=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:f}),e.st){var Z=new Float32Array(O/3*2),$=0;if(E){u/=3,m/=3;var tt,et=Math.PI/(T+1),rt=1/(u-T+1),at=1/(m-T+1),it=T/2;for(mt=1+it;mt<T+1;mt++)tt=ft.CesiumMath.PI_OVER_TWO+et*mt,Z[$++]=at*(1+Math.cos(tt)),Z[$++]=.5*(1+Math.sin(tt));for(mt=1;mt<m-T+1;mt++)Z[$++]=mt*at,Z[$++]=0;for(mt=T;it<mt;mt--)tt=ft.CesiumMath.PI_OVER_TWO-mt*et,Z[$++]=1-at*(1+Math.cos(tt)),Z[$++]=.5*(1+Math.sin(tt));for(mt=it;0<mt;mt--)tt=ft.CesiumMath.PI_OVER_TWO-et*mt,Z[$++]=1-rt*(1+Math.cos(tt)),Z[$++]=.5*(1+Math.sin(tt));for(mt=u-T;0<mt;mt--)Z[$++]=mt*rt,Z[$++]=1;for(mt=1;mt<1+it;mt++)tt=ft.CesiumMath.PI_OVER_TWO+et*mt,Z[$++]=rt*(1+Math.cos(tt)),Z[$++]=.5*(1+Math.sin(tt))}else if((u/=3)===(m/=3)){for(var i=ct.Cartesian3.unpackArray(f),nt=ct.Cartesian3.multiplyByScalar(ct.Cartesian3.add(i.shift(),i.pop()),.5,new ct.Cartesian3),ot=0,st=[],lt=0;i.length;){var dt=ct.Cartesian3.multiplyByScalar(ct.Cartesian3.add(i.shift(),i.pop()),.5,new ct.Cartesian3),ot=ct.Cartesian3.distance(dt,nt);st.push(ot),lt+=ot,nt=dt}Z[$++]=0,Z[$++]=0;var ut=2*(u+m)-1;Z[ut--]=1;for(var mt=ot=Z[ut--]=0,_=st.length;mt<_;mt++){var yt=(ot+=st[mt])/lt;Z[$++]=yt,Z[$++]=0,Z[ut--]=1,Z[ut--]=yt}}else{for(rt=1/(u-1),at=1/(m-1),mt=0;mt<m;mt++)Z[$++]=mt*at,Z[$++]=0;for(mt=u;0<mt;mt--)Z[$++]=(mt-1)*rt,Z[$++]=1}d.st=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:Z})}return e.normal&&(d.normal=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:c.normals})),e.tangent&&(d.tangent=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:c.tangents})),e.bitangent&&(d.bitangent=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:c.bitangents})),{attributes:d,indices:p}}function M(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(var a=3;a<t.length;a+=3){var i=t[a],n=t[a+1],o=t[a+2];r[e++]=i,r[e++]=n,r[e++]=o,r[e++]=i,r[e++]=n,r[e++]=o}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}function A(t,e){var r=new x.VertexFormat({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),a=t.ellipsoid,i=I(At.CorridorGeometryLibrary.computePositions(t),r,a),n=t.height,o=t.extrudedHeight,s=i.attributes,l=i.indices,d=s.position.values,u=d.length,m=new Float64Array(6*u),y=new Float64Array(u);y.set(d);var p=new Float64Array(4*u),p=M(d=N.PolygonPipeline.scaleToGeodeticHeight(d,n,a),0,p);p=M(y=N.PolygonPipeline.scaleToGeodeticHeight(y,o,a),2*u,p),m.set(d),m.set(y,u),m.set(p,2*u),s.position.values=m,s=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;var r,a,i=t.position.values;(e.normal||e.bitangent)&&(r=t.normal.values,a=t.bitangent.values);var n=t.position.values.length/18,o=3*n,s=2*n,l=2*o;if(e.normal||e.bitangent||e.tangent){for(var d,u=e.normal?new Float32Array(6*o):void 0,m=e.tangent?new Float32Array(6*o):void 0,y=e.bitangent?new Float32Array(6*o):void 0,p=vt,f=wt,c=_t,h=Gt,g=O,C=Tt,b=l,A=0;A<o;A+=3){var v=b+l,p=ct.Cartesian3.fromArray(i,A,p),f=ct.Cartesian3.fromArray(i,A+o,f),c=ct.Cartesian3.fromArray(i,(A+3)%o,c);f=ct.Cartesian3.subtract(f,p,f),c=ct.Cartesian3.subtract(c,p,c),h=ct.Cartesian3.normalize(ct.Cartesian3.cross(f,c,h),h),e.normal&&(At.CorridorGeometryLibrary.addAttribute(u,h,v),At.CorridorGeometryLibrary.addAttribute(u,h,v+3),At.CorridorGeometryLibrary.addAttribute(u,h,b),At.CorridorGeometryLibrary.addAttribute(u,h,b+3)),(e.tangent||e.bitangent)&&(C=ct.Cartesian3.fromArray(r,A,C),e.bitangent&&(At.CorridorGeometryLibrary.addAttribute(y,C,v),At.CorridorGeometryLibrary.addAttribute(y,C,v+3),At.CorridorGeometryLibrary.addAttribute(y,C,b),At.CorridorGeometryLibrary.addAttribute(y,C,b+3)),e.tangent&&(g=ct.Cartesian3.normalize(ct.Cartesian3.cross(C,h,g),g),At.CorridorGeometryLibrary.addAttribute(m,g,v),At.CorridorGeometryLibrary.addAttribute(m,g,v+3),At.CorridorGeometryLibrary.addAttribute(m,g,b),At.CorridorGeometryLibrary.addAttribute(m,g,b+3))),b+=6}if(e.normal){for(u.set(r),A=0;A<o;A+=3)u[A+o]=-r[A],u[A+o+1]=-r[A+1],u[A+o+2]=-r[A+2];t.normal.values=u}else t.normal=void 0;e.bitangent?(y.set(a),y.set(a,o),t.bitangent.values=y):t.bitangent=void 0,e.tangent&&(d=t.tangent.values,m.set(d),m.set(d,o),t.tangent.values=m)}if(e.st){var w=t.st.values,_=new Float32Array(6*s);_.set(w),_.set(w,s);for(var G=2*s,T=0;T<2;T++){for(_[G++]=w[0],_[G++]=w[1],A=2;A<s;A+=2){var E=w[A],F=w[A+1];_[G++]=E,_[G++]=F,_[G++]=E,_[G++]=F}_[G++]=w[0],_[G++]=w[1]}t.st.values=_}return t}(s,e);var f,c,h=u/3;if(t.shadowVolume){for(var g=s.normal.values,u=g.length,C=new Float32Array(6*u),b=0;b<u;b++)g[b]=-g[b];C.set(g,u),C=M(g,4*u,C),s.extrudeDirection=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C}),e.normal||(s.normal=void 0)}pt.defined(t.offsetAttribute)&&(c=new Uint8Array(6*h),c=t.offsetAttribute===P.GeometryOffsetAttribute.TOP?(c=P.arrayFill(c,1,0,h),P.arrayFill(c,1,2*h,4*h)):(f=t.offsetAttribute===P.GeometryOffsetAttribute.NONE?0:1,P.arrayFill(c,f)),s.applyOffset=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:c}));var A=l.length,v=h+h,w=bt.IndexDatatype.createTypedArray(m.length/3,2*A+3*v);w.set(l);var _,G,T,E,F=A;for(b=0;b<A;b+=3){var L=l[b],D=l[b+1],V=l[b+2];w[F++]=V+h,w[F++]=D+h,w[F++]=L+h}for(b=0;b<v;b+=2)T=(_=b+v)+1,E=(G=_+v)+1,w[F++]=_,w[F++]=G,w[F++]=T,w[F++]=T,w[F++]=G,w[F++]=E;return{attributes:s,indices:w}}var v=new ct.Cartesian3,w=new ct.Cartesian3,_=new c.Cartographic;function f(t,e,r,a,i,n){var o=ct.Cartesian3.subtract(e,t,v);ct.Cartesian3.normalize(o,o);var s=r.geodeticSurfaceNormal(t,w),l=ct.Cartesian3.cross(o,s,v);ct.Cartesian3.multiplyByScalar(l,a,l);var d=i.latitude,u=i.longitude,m=n.latitude,y=n.longitude;ct.Cartesian3.add(t,l,w),r.cartesianToCartographic(w,_);var p=_.latitude,f=_.longitude,d=Math.min(d,p),u=Math.min(u,f),m=Math.max(m,p),y=Math.max(y,f);ct.Cartesian3.subtract(t,l,w),r.cartesianToCartographic(w,_),p=_.latitude,f=_.longitude,d=Math.min(d,p),u=Math.min(u,f),m=Math.max(m,p),y=Math.max(y,f),i.latitude=d,i.longitude=u,n.latitude=m,n.longitude=y}var G=new ct.Cartesian3,T=new ct.Cartesian3,E=new c.Cartographic,F=new c.Cartographic;function m(t,e,r,a,i){t=b(t,e);var n=g.arrayRemoveDuplicates(t,ct.Cartesian3.equalsEpsilon),o=n.length;if(o<2||r<=0)return new c.Rectangle;var s,l,d,u=.5*r;E.latitude=Number.POSITIVE_INFINITY,E.longitude=Number.POSITIVE_INFINITY,F.latitude=Number.NEGATIVE_INFINITY,F.longitude=Number.NEGATIVE_INFINITY,a===C.CornerType.ROUNDED&&(d=n[0],ct.Cartesian3.subtract(d,n[1],G),ct.Cartesian3.normalize(G,G),ct.Cartesian3.multiplyByScalar(G,u,G),ct.Cartesian3.add(d,G,T),e.cartesianToCartographic(T,_),s=_.latitude,l=_.longitude,E.latitude=Math.min(E.latitude,s),E.longitude=Math.min(E.longitude,l),F.latitude=Math.max(F.latitude,s),F.longitude=Math.max(F.longitude,l));for(var m=0;m<o-1;++m)f(n[m],n[m+1],e,u,E,F);var y=n[o-1];ct.Cartesian3.subtract(y,n[o-2],G),ct.Cartesian3.normalize(G,G),ct.Cartesian3.multiplyByScalar(G,u,G),ct.Cartesian3.add(y,G,T),f(y,T,e,u,E,F),a===C.CornerType.ROUNDED&&(e.cartesianToCartographic(T,_),s=_.latitude,l=_.longitude,E.latitude=Math.min(E.latitude,s),E.longitude=Math.min(E.longitude,l),F.latitude=Math.max(F.latitude,s),F.longitude=Math.max(F.longitude,l));var p=pt.defined(i)?i:new c.Rectangle;return p.north=F.latitude,p.south=E.latitude,p.east=F.longitude,p.west=E.longitude,p}function L(t){var e=(t=pt.defaultValue(t,pt.defaultValue.EMPTY_OBJECT)).positions,r=t.width,a=pt.defaultValue(t.height,0),i=pt.defaultValue(t.extrudedHeight,a);this._positions=e,this._ellipsoid=c.Ellipsoid.clone(pt.defaultValue(t.ellipsoid,c.Ellipsoid.WGS84)),this._vertexFormat=x.VertexFormat.clone(pt.defaultValue(t.vertexFormat,x.VertexFormat.DEFAULT)),this._width=r,this._height=Math.max(a,i),this._extrudedHeight=Math.min(a,i),this._cornerType=pt.defaultValue(t.cornerType,C.CornerType.ROUNDED),this._granularity=pt.defaultValue(t.granularity,ft.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=pt.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*ct.Cartesian3.packedLength+c.Ellipsoid.packedLength+x.VertexFormat.packedLength+7}L.pack=function(t,e,r){r=pt.defaultValue(r,0);var a=t._positions,i=a.length;e[r++]=i;for(var n=0;n<i;++n,r+=ct.Cartesian3.packedLength)ct.Cartesian3.pack(a[n],e,r);return c.Ellipsoid.pack(t._ellipsoid,e,r),r+=c.Ellipsoid.packedLength,x.VertexFormat.pack(t._vertexFormat,e,r),r+=x.VertexFormat.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=pt.defaultValue(t._offsetAttribute,-1),e};var D=c.Ellipsoid.clone(c.Ellipsoid.UNIT_SPHERE),V=new x.VertexFormat,S={positions:void 0,ellipsoid:D,vertexFormat:V,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return L.unpack=function(t,e,r){e=pt.defaultValue(e,0);for(var a=t[e++],i=new Array(a),n=0;n<a;++n,e+=ct.Cartesian3.packedLength)i[n]=ct.Cartesian3.unpack(t,e);var o=c.Ellipsoid.unpack(t,e,D);e+=c.Ellipsoid.packedLength;var s=x.VertexFormat.unpack(t,e,V);e+=x.VertexFormat.packedLength;var l=t[e++],d=t[e++],u=t[e++],m=t[e++],y=t[e++],p=1===t[e++],f=t[e];return pt.defined(r)?(r._positions=i,r._ellipsoid=c.Ellipsoid.clone(o,r._ellipsoid),r._vertexFormat=x.VertexFormat.clone(s,r._vertexFormat),r._width=l,r._height=d,r._extrudedHeight=u,r._cornerType=m,r._granularity=y,r._shadowVolume=p,r._offsetAttribute=-1===f?void 0:f,r):(S.positions=i,S.width=l,S.height=d,S.extrudedHeight=u,S.cornerType=m,S.granularity=y,S.shadowVolume=p,S.offsetAttribute=-1===f?void 0:f,new L(S))},L.computeRectangle=function(t,e){var r=(t=pt.defaultValue(t,pt.defaultValue.EMPTY_OBJECT)).positions,a=t.width;return m(r,pt.defaultValue(t.ellipsoid,c.Ellipsoid.WGS84),a,pt.defaultValue(t.cornerType,C.CornerType.ROUNDED),e)},L.createGeometry=function(t){var e=t._positions,r=t._width,a=t._ellipsoid,i=t._vertexFormat;if(t._cornerType===C.CornerType.EV_ARC){if(e.length<2||r<=0)return;var n=function(t,e){var r=t.positions,a=t.normals,i=new Ct.GeometryAttributes,n=r.length,o=new Float64Array(3*n),s=ct.Cartesian3.packArray(r);o.set(s,0),i.position=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:o});for(var l,d,u,m,y,p,f=3*(n-2),c=bt.IndexDatatype.createTypedArray(n,f),h=0,g=n-1,C=0,b=n/2-1,A=0;A<b;A++)u=1+(m=h++),l=(d=g--)-1,c[C++]=l,c[C++]=d,c[C++]=u,c[C++]=u,c[C++]=d,c[C++]=m;if(e.st){for(var v=0,w=[],_=0,G=O,T=Tt,G=ct.Cartesian3.multiplyByScalar(ct.Cartesian3.add(r[0],r[n-1]),.5,G),b=n-1,A=1,E=n/2;A<E;A++)T=ct.Cartesian3.multiplyByScalar(ct.Cartesian3.add(r[A],r[b-A]),.5,T),v=ct.Cartesian3.distance(T,G),w.push(v),_+=v,G=ct.Cartesian3.clone(T);var F=new Float32Array(2*n),L=0;F[L++]=0,F[L++]=0;var D=2*n-1;F[D--]=1;for(var A=v=F[D--]=0,V=w.length;A<V;A++){var P=(v+=w[A])/_;F[L++]=P,F[L++]=0,F[D--]=1,F[D--]=P}i.st=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:F})}return e.normal&&(y=ct.Cartesian3.packArray(a),(p=new Float32Array(3*n)).set(y),i.normal=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),{attributes:i,indices:c}}(At.CorridorGeometryLibrary.ev_computePositions({positions:e,width:r,ellipsoid:a,interpolationCount:1e3}),i);pt.defined(t._offsetAttribute)&&(s=t._offsetAttribute===P.GeometryOffsetAttribute.NONE?0:1,l=n.attributes.position.values.length,d=new Uint8Array(l/3),P.arrayFill(d,s),n.attributes.applyOffset=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:d}))}else{e=b(e,a);var o=g.arrayRemoveDuplicates(e,ct.Cartesian3.equalsEpsilon);if(o.length<2||r<=0)return;var s,l,d,u=t._height,m=t._extrudedHeight,y=!ft.CesiumMath.equalsEpsilon(u,m,0,ft.CesiumMath.EPSILON2),p={ellipsoid:a,positions:o,width:r,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!0};y?(p.height=u,p.extrudedHeight=m,p.shadowVolume=t._shadowVolume,p.offsetAttribute=t._offsetAttribute,n=A(p,i)):((n=I(At.CorridorGeometryLibrary.computePositions(p),i,a)).attributes.position.values=N.PolygonPipeline.scaleToGeodeticHeight(n.attributes.position.values,u,a),pt.defined(t._offsetAttribute)&&(s=t._offsetAttribute===P.GeometryOffsetAttribute.NONE?0:1,l=n.attributes.position.values.length,d=new Uint8Array(l/3),P.arrayFill(d,s),n.attributes.applyOffset=new gt.GeometryAttribute({componentDatatype:ht.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:d})))}var f=n.attributes,c=h.BoundingSphere.fromVertices(f.position.values,void 0,3);return i.position||(n.attributes.position.values=void 0),new gt.Geometry({attributes:f,indices:n.indices,primitiveType:gt.PrimitiveType.TRIANGLES,boundingSphere:c,offsetAttribute:t._offsetAttribute})},L.createShadowVolume=function(t,e,r){var a=t._granularity,i=t._ellipsoid,n=e(a,i),o=r(a,i);return new L({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:n,height:o,vertexFormat:x.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(L.prototype,{rectangle:{get:function(){return pt.defined(this._rectangle)||(this._rectangle=m(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return pt.defined(e)&&(t=L.unpack(t,e)),t._ellipsoid=c.Ellipsoid.clone(t._ellipsoid),L.createGeometry(t)}});
